---
title: "Gwiezdne Horyzonty 2125"
subtitle: "Roczna Analiza Strategiczna Space-U"
author: "ZespÃ³Å‚ Analiz Biznesowych Space-U"
lang: pl-PL
date: "2125-06-13"
date-format: "long"
format:
  html:
    toc: true
    number-sections: false
    code-fold: true
    theme:
      light: flatly
      dark: darkly
    page-layout: full
---

# WstÄ™p
W bezkresie kosmosu, podobnie jak w oceanie danych, kluczem do sukcesu jest precyzyjna nawigacja. Od ponad dekady misjÄ… Space-U jest nie tylko otwieranie ludzkoÅ›ci drogi do gwiazd, ale rÃ³wnieÅ¼ prowadzenie tej ekspansji w sposÃ³b mÄ…dry, zrÃ³wnowaÅ¼ony i rentowny. Rok 2034 byÅ‚ kolejnym kamieniem milowym na naszej orbicie sukcesu â€“ rokiem, w ktÃ³rym umocniliÅ›my naszÄ… pozycjÄ™ lidera, wysÅ‚aliÅ›my rekordowÄ… liczbÄ™ pasaÅ¼erÃ³w ku czerwonym piaskom Marsa i zorzom Jowisza, ale takÅ¼e zmierzyliÅ›my siÄ™ z nowymi, nieprzewidzianymi wyzwaniami.

Niniejszy raport jest naszÄ… mapÄ… nawigacyjnÄ… po minionym roku. Z kosmicznÄ… precyzjÄ… przeanalizowaliÅ›my zebrane dane, aby odpowiedzieÄ‡ na fundamentalne pytania. KtÃ³re trajektorie lotÃ³w przynoszÄ… najwiÄ™ksze zyski? Jak zmienia siÄ™ profil demograficzny naszych miÄ™dzyplanetarnych podrÃ³Å¼nikÃ³w? Gdzie leÅ¼Ä… ukryte ryzyka operacyjne â€“ czy to w pasie asteroid, czy w awaryjnoÅ›ci naszych statkÃ³w? I wreszcie â€“ jak odczucia i oceny naszych klientÃ³w korelujÄ… z incydentami napotkanymi w drodze na orbitÄ™?

Celem tego dokumentu nie jest jedynie kronikarski zapis przeszÅ‚oÅ›ci. To przede wszystkim kompas, ktÃ³ry ma wskazaÄ‡ kierunek przyszÅ‚ych dziaÅ‚aÅ„. Wnioski tu zawarte stanowiÄ… solidny, oparty na twardych danych fundament pod strategiczne decyzje, ktÃ³re wyznaczÄ… kurs Space-U na kolejne lata. Informacje te pozwolÄ… nam nie tylko optymalizowaÄ‡ obecne operacje, ale takÅ¼e odkrywaÄ‡ zupeÅ‚nie nowe konstelacje moÅ¼liwoÅ›ci rynkowych.

Zapnijcie pasy. Wyruszamy w podrÃ³Å¼ po danych, ktÃ³ra uksztaÅ‚tuje przyszÅ‚oÅ›Ä‡ miÄ™dzyplanetarnych podrÃ³Å¼y.

# Analiza danych

```{python}
#| echo: false
#| include: false
import random
import math
from datetime import date, datetime, timedelta, time
import numpy as np
import pandas as pd
import mysql.connector
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from scipy import stats
from sqlalchemy import create_engine, text
from urllib.parse import quote_plus
from pandas.tseries.offsets import DateOffset 
import plotly.io as pio
from IPython.display import Markdown
import plotly.graph_objects as go
pio.templates.default = "plotly_white" 
```

```{python}
#| echo: false
#| include: false
from sqlalchemy import create_engine
from urllib.parse import quote_plus

host = "giniewicz.it"           # â† bez 'mlie@'
user = "team13"
password = "te@mlie"
database = "team13"

safe_password = quote_plus(password)

# JeÅ›li port to 3306 i nie trzeba podawaÄ‡ innego
connection_uri = f"mysql+pymysql://{user}:{safe_password}@{host}/{database}"
engine = create_engine(connection_uri)
```

## Analiza rentownoÅ›ci i popularnoÅ›ci wypraw

W tej kluczowej sekcji raportu dokonujemy szczegÃ³Å‚owego przeglÄ…du naszego portfolio usÅ‚ug. Naszym celem jest precyzyjne zidentyfikowanie, ktÃ³re rodzaje wypraw stanowiÄ… trzon naszej oferty â€“ cieszÄ…c siÄ™ najwiÄ™kszym zainteresowaniem klientÃ³w â€“ oraz, co najwaÅ¼niejsze, jak popularnoÅ›Ä‡ ta przekÅ‚ada siÄ™ na wyniki finansowe. Zrozumienie rentownoÅ›ci poszczegÃ³lnych "produktÃ³w" jest fundamentem do podejmowania Å›wiadomych decyzji o alokacji zasobÃ³w, strategii cenowej i przyszÅ‚ych inwestycjach w rozwÃ³j floty oraz nowych tras.

Analiza zostaÅ‚a przeprowadzona na podstawie peÅ‚nych danych operacyjnych i finansowych z czterech lat dziaÅ‚alnoÅ›ci naszej firmy. WykorzystaliÅ›my do tego bezpoÅ›rednie zapytanie do naszej centralnej bazy danych, agregujÄ…c informacje o liczbie lotÃ³w, caÅ‚kowitych kosztach misji oraz skompletowanych transakcjach.

```{python}
query = """
SELECT
    tt.name AS 'Rodzaj wyprawy',
    COUNT(t.trip_id) AS 'Liczba wypraw',
    COALESCE(SUM(ac.total_trip_cost), 0) AS 'CaÅ‚kowite koszty',
    COALESCE(SUM(ar.total_trip_revenue), 0) AS 'CaÅ‚kowite przychody',
    (COALESCE(SUM(ar.total_trip_revenue), 0) - COALESCE(SUM(ac.total_trip_cost), 0)) AS 'Zysk'
FROM
    trip_types tt
LEFT JOIN
    trips t ON tt.trip_type_id = t.trip_type_id
LEFT JOIN
    (SELECT trip_id, SUM(cost_amount) AS total_trip_cost FROM costs GROUP BY trip_id) ac 
    ON t.trip_id = ac.trip_id
LEFT JOIN
    (SELECT trip_id, SUM(amount) AS total_trip_revenue FROM transactions WHERE status = 'Completed' GROUP BY trip_id) ar 
    ON t.trip_id = ar.trip_id
GROUP BY
    tt.name
ORDER BY
    `Liczba wypraw` DESC;
"""
```

```{python}
df_profitability = pd.read_sql(query, engine)

display(df_profitability.style.format('{:,.2f} zÅ‚', subset=['CaÅ‚kowite koszty', 'CaÅ‚kowite przychody', 'Zysk'], decimal=',', thousands=' ')\
                         .format('{}', subset=['Liczba wypraw'])\
                         .set_caption("PopularnoÅ›Ä‡ i rentownoÅ›Ä‡ typÃ³w wypraw")\
                         .background_gradient(cmap='RdYlGn', subset=['Zysk']))
```


PoniÅ¼sza tabela prezentuje kompleksowe zestawienie kluczowych wskaÅºnikÃ³w dla kaÅ¼dego typu wyprawy

```{python}
#| echo: false
#| include: false
print("\n\n--- Wnioski ---")
print("\nNajpopularniejsze rodzaje wypraw:\n")
top_3_profitability = df_profitability.head(3)

for index, row in top_3_profitability.iterrows():
    print(
        f"{index + 1}. Rodzaj '{row['Rodzaj wyprawy']}': "
        f"{row['Liczba wypraw']} wypraw, "
        f"ktÃ³re przyniosÅ‚y {row['CaÅ‚kowite przychody']:.2f} przychodu."
    )

print("\nAnaliza rentownoÅ›ci rodzajÃ³w wypraw:\n")
unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]
if unprofitable_types.empty:
    print("Wszystkie rodzaje wypraw sÄ… opÅ‚acalne i nie przynoszÄ… strat.")
else:
    print("UWAGA! NastÄ™pujÄ…ce rodzaje wypraw przynoszÄ… straty:")
    for index, row in unprofitable_types.iterrows():
        print(
            f"- '{row['Rodzaj wyprawy']}': zanotowano stratÄ™ w wysokoÅ›ci {-row['Zysk']:.2f}"
        )

print("\n----------------------------------")
```

```{python}
#| echo: false

top_3_profitability = df_profitability.head(3)
wnioski_markdown = """
### Liderzy PopularnoÅ›ci
Nasze dane jednoznacznie wskazujÄ… na grupÄ™ flagowych produktÃ³w, ktÃ³re stanowiÄ… o sile naszej marki. PoniÅ¼ej przedstawiamy TOP 3 najchÄ™tniej wybierane wyprawy:
<ul>
"""

for _, row in top_3_profitability.iterrows():
    liczba_wypraw_str = f"<b>{row['Liczba wypraw']}</b>"
    przychody_str = f"<b>{row['CaÅ‚kowite przychody']:,.2f} zÅ‚</b>"
    wnioski_markdown += (
        f"<li><b>{row['Rodzaj wyprawy']}</b>: zrealizowano {liczba_wypraw_str} wypraw, "
        f"ktÃ³re przyniosÅ‚y {przychody_str} przychodu.</li>\n"
    )

wnioski_markdown += "</ul>"

display(Markdown(wnioski_markdown))
```

```{python}
#| echo: false

unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]

rentownosc_markdown = """
### Analiza RentownoÅ›ci
"""

if unprofitable_types.empty:
    rentownosc_markdown += (
        "<p style='color: #198754;'><b>DoskonaÅ‚e wieÅ›ci:</b> W analizowanym okresie wszystkie oferowane przez Space-U rodzaje wypraw "
        "okazaÅ‚y siÄ™ rentowne. To Å›wiadczy o zdrowej strukturze kosztÃ³w i dobrze skalibrowanej polityce cenowej w caÅ‚ym naszym portfolio.</p>"
    )
else:
    rentownosc_markdown += (
        "<p style='color: #dc3545;'><b>Uwaga ZarzÄ…dcza:</b> Zidentyfikowano nastÄ™pujÄ…ce rodzaje wypraw, ktÃ³re generujÄ… straty. "
        "Rekomendujemy przeprowadzenie dogÅ‚Ä™bnej analizy ich struktury kosztÃ³w oraz efektywnoÅ›ci operacyjnej:</p>"
        "<ul>"
    )
    for _, row in unprofitable_types.iterrows():
        strata_str = f"<b style='color: #dc3545;'>{-row['Zysk']:,.2f} zÅ‚</b>"
        rentownosc_markdown += f"<li><b>{row['Rodzaj wyprawy']}</b>: zanotowano stratÄ™ w wysokoÅ›ci {strata_str}.</li>\n"
    rentownosc_markdown += "</ul>"

display(Markdown(rentownosc_markdown))
```

## Analiza Dynamiki Bazy KlientÃ³w

Analiza miesiÄ™cznej liczby obsÅ‚uÅ¼onych klientÃ³w jest jednym z fundamentalnych wskaÅºnikÃ³w kondycji i tempa rozwoju Space-U. To puls naszej dziaÅ‚alnoÅ›ci, ktÃ³ry pozwala oceniÄ‡ skutecznoÅ›Ä‡ naszych dziaÅ‚aÅ„ marketingowych, atrakcyjnoÅ›Ä‡ oferty oraz ogÃ³lne zainteresowanie podrÃ³Å¼ami kosmicznymi. W tej sekcji zbadamy, czy w ostatnim roku nasza firma znajdowaÅ‚a siÄ™ na trajektorii wzrostowej, czy teÅ¼ napotkaÅ‚a na turbulencje.

Aby odpowiedzieÄ‡ na to pytanie, stworzyliÅ›my wizualizacjÄ™ przedstawiajÄ…cÄ… liczbÄ™ unikalnych klientÃ³w w kaÅ¼dym miesiÄ…cu. Zamiast polegaÄ‡ na subiektywnej ocenie, naÅ‚oÅ¼yliÅ›my na dane liniÄ™ trendu opartÄ… na regresji liniowej, ktÃ³ra w obiektywny sposÃ³b wskazuje kierunek, w ktÃ³rym zmierzamy.

```{python}
query_clients_per_month = text("""
SELECT
    DATE_FORMAT(transaction_date, '%Y-%m') AS miesiac,
    COUNT(DISTINCT client_id) AS liczba_klientow
FROM transactions
WHERE transaction_date < '2125-06-13'
GROUP BY miesiac
ORDER BY miesiac;
""")


```
```{python}
df_clients = pd.read_sql_query(query_clients_per_month, engine)
df_clients['srednia_kroczaca'] = df_clients['liczba_klientow'].rolling(window=3, center=True, min_periods=1).mean()
```

```{python}
#| include: false
#| echo: false
plt.figure(figsize=(14, 7))
sns.barplot(data=df_clients, x='miesiac', y='liczba_klientow', color='steelblue')
plt.title('MiesiÄ™czna liczba obsÅ‚uÅ¼onych klientÃ³w', fontsize=16)
plt.xlabel('MiesiÄ…c', fontsize=12)
plt.ylabel('Liczba klientÃ³w', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
x = np.arange(len(df_clients)) 
y = df_clients['liczba_klientow'] 
slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
stagnation_threshold = 0.5

if slope > stagnation_threshold:
    wniosek = f"Firma wykazuje wyraÅºny trend WZROSTOWY."
    szczegoly = f"Åšrednio, z kaÅ¼dym miesiÄ…cem liczba klientÃ³w roÅ›nie o {slope:.2f}."
elif slope < -stagnation_threshold:
    wniosek = f"Firma wykazuje wyraÅºny trend SPADKOWY."
    szczegoly = f"Åšrednio, z kaÅ¼dym miesiÄ…cem liczba klientÃ³w maleje o {-slope:.2f}."
else:
    wniosek = "Firma wykazuje STAGNACJÄ˜."
    szczegoly = f"Brak wyraÅºnego trendu wzrostowego lub spadkowego (nachylenie linii trendu wynosi {slope:.2f})."
```

PoniÅ¼szy wykres prezentuje miesiÄ™czne dane wraz z wygÅ‚adzonÄ… liniÄ… trendu (Å›rednia kroczÄ…ca), ktÃ³ra pomaga zwizualizowaÄ‡ ogÃ³lnÄ… tendencjÄ™.
```{python}
#| echo: false
fig = go.Figure()
fig.add_trace(
    go.Bar(
        x=df_clients['miesiac'],
        y=df_clients['liczba_klientow'],
        name='Liczba klientÃ³w w miesiÄ…cu',
        marker_color='skyblue',
        opacity=0.7
    )
)
fig.add_trace(
    go.Scatter(
        x=df_clients['miesiac'],
        y=df_clients['srednia_kroczaca'],
        name='Trend (Å›rednia kroczÄ…ca)',
        mode='lines',
        line=dict(color='crimson', width=3)
    )
)
fig.update_layout(
    title='MiesiÄ™czna liczba obsÅ‚uÅ¼onych klientÃ³w i linia trendu',
    xaxis_title='MiesiÄ…c',
    yaxis_title='Liczba KlientÃ³w',
    legend_title='Legenda',
    xaxis_tickangle=-45,
    bargap=0.2,
    xaxis={'type': 'category'} 
)

fig.show()
```

```{python}
analiza_markdown = f"""
### Ocena Linii Trendu 
<p>Analiza statystyczna oparta na regresji liniowej pozwala nam obiektywnie oceniÄ‡ kierunek rozwoju firmy. WspÃ³Å‚czynnik nachylenia linii trendu to matematyczna reprezentacja naszego miesiÄ™cznego wzrostu lub spadku.</p>
<p><b>Wniosek: {wniosek}</b></p>
<p>{szczegoly}</p>
"""
display(Markdown(analiza_markdown))
```

## Analiza ryzyka operacyjnego
ZarzÄ…dzanie ryzykiem w turystyce kosmicznej to nie tylko nasz obowiÄ…zek, ale fundament, na ktÃ³rym opiera siÄ™ zaufanie naszych klientÃ³w i partnerÃ³w. W tej czÄ™Å›ci raportu dokonujemy dogÅ‚Ä™bnej analizy dwÃ³ch gÅ‚Ã³wnych ÅºrÃ³deÅ‚ ryzyka: niebezpieczeÅ„stw zwiÄ…zanych z celem podrÃ³Å¼y oraz potencjalnej awaryjnoÅ›ci naszych statkÃ³w kosmicznych. Celem jest identyfikacja "gorÄ…cych punktÃ³w", ktÃ³ra pozwoli na wdroÅ¼enie dziaÅ‚aÅ„ prewencyjnych i podniesienie standardÃ³w bezpieczeÅ„stwa.

### Ryzyko zwiÄ…zane z destynacja
KaÅ¼da destynacja w UkÅ‚adzie SÅ‚onecznym posiada unikalnÄ… charakterystykÄ™ i wiÄ…Å¼e siÄ™ z rÃ³Å¼nym poziomem wyzwaÅ„. PoniÅ¼szy wykres przedstawia liczbÄ™ zarejestrowanych incydentÃ³w w podziale na lokalizacje oraz stopieÅ„ ich powagi (niski, Å›redni, wysoki).

```{python}
#| include: false
#| echo: false
query_risky_destinations = """
SELECT 
    destinations.name AS kierunek, 
    COUNT(*) AS liczba_wypadkow
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    destinations
ON
    trips.destination_id = destinations.destination_id
GROUP BY
    kierunek
ORDER BY
    liczba_wypadkow DESC;
"""
```
```{python}
#| include: false
#| echo: false
query_risky_dest2 = """
SELECT
    d.name AS kierunek,
    COALESCE(tpd.total_trips, 0) AS liczba_wypraw,
    COALESCE(ipd.total_incidents, 0) AS liczba_incydentow,
    (COALESCE(ipd.total_incidents, 0) * 100.0 / tpd.total_trips) AS wskaznik_ryzyka_procent
FROM
    destinations d
JOIN
    (
        SELECT destination_id, COUNT(trip_id) AS total_trips
        FROM trips
        GROUP BY destination_id
    ) AS tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    (
        SELECT t.destination_id, COUNT(i.incident_id) AS total_incidents
        FROM incidents i
        JOIN trips t ON i.trip_id = t.trip_id
        GROUP BY t.destination_id
    ) AS ipd ON d.destination_id = ipd.destination_id
ORDER BY
    wskaznik_ryzyka_procent DESC;
"""
```
```{python}
#| include: false
#| echo: false
df_risky_destinations = pd.read_sql(query_risky_destinations, engine)
print(df_risky_destinations.to_string())
```
```{python}
#| include: false
#| echo: false
df_risky_destinations2 = pd.read_sql(query_risky_dest2, engine)
print(df_risky_destinations2.to_string())
```

```{python}
query_incidents_graph = """
SELECT
    d.name AS kierunek,
    i.severity,
    COUNT(i.incident_id) AS liczba_incydentow
FROM
    incidents i
JOIN
    trips t ON i.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE
    i.severity IN ('high', 'medium', 'low')
GROUP BY
    d.name, i.severity
"""
```
```{python}
df_incidents_long = pd.read_sql(query_incidents_graph, engine)
```
```{python}
df_total_incidents = df_incidents_long.groupby('kierunek')['liczba_incydentow'].sum().sort_values(ascending=False)
df_incidents_long['kierunek_sorted'] = pd.Categorical(df_incidents_long['kierunek'], categories=df_total_incidents.index, ordered=True)

fig = px.bar(
    df_incidents_long.sort_values('kierunek_sorted'), 
    x='kierunek_sorted', 
    y='liczba_incydentow', 
    color='severity',
    title='Liczba incydentÃ³w ze wzglÄ™du na destynacjÄ™',
    labels={'kierunek_sorted': 'Destynacja', 'liczba_incydentow': 'ÅÄ…czna liczba incydentÃ³w', 'severity': 'Poziom zagroÅ¼enia'},
    color_discrete_map={'low': '#5cb85c', 'medium': '#f0ad4e', 'high': '#d9534f'},
    category_orders={'severity': ['low', 'medium', 'high']}
)
fig.show()
```
```{python}
#| include: false
#| echo: false
df_incidents_wide = df_incidents_long.pivot_table(
    index='kierunek', 
    columns='severity', 
    values='liczba_incydentow',
    fill_value=0
)
color_map = {'high': '#d9534f', 'medium': '#f0ad4e', 'low': '#5cb85c'}
desired_order = ['low', 'medium', 'high']
ordered_columns = [col for col in desired_order if col in df_incidents_wide.columns]
df_incidents_wide = df_incidents_wide[ordered_columns]
```

```{python}
#| include: false
#| echo: false
df_incidents_wide.plot(
    kind='bar', 
    stacked=True, 
    color=color_map,
    figsize=(14, 8)
)
plt.title('Liczba incydentÃ³w wedÅ‚ug destynacji', fontsize=16)
plt.xlabel('Destynacja', fontsize=12)
plt.ylabel('ÅÄ…czna liczba incydentÃ³w', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.legend(title='Poziom zagroÅ¼enia')
plt.tight_layout()
plt.show()
```

Sama liczba incydentÃ³w moÅ¼e byÄ‡ jednak mylÄ…ca â€“ popularna destynacja naturalnie odnotuje wiÄ™cej zdarzeÅ„. Aby uzyskaÄ‡ bardziej obiektywny obraz, stworzyliÅ›my waÅ¼ony wskaÅºnik ryzyka. Przypisuje on punkty za kaÅ¼dy incydent w zaleÅ¼noÅ›ci od jego wagi (10 pkt za "High", 3 za "Medium", 1 za "Low"), a nastÄ™pnie dzieli sumÄ™ punktÃ³w przez liczbÄ™ wypraw do danej lokalizacji. Wynik pokazuje Å›rednie "obciÄ…Å¼enie ryzykiem" na jednÄ… wyprawÄ™.

```{python}
query_weighted_risk = """
WITH trips_per_destination AS (
    SELECT destination_id, COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY destination_id
),
weighted_incidents AS (
    SELECT 
        t.destination_id,
        SUM(
            CASE 
                WHEN i.severity = 'High' THEN 10
                WHEN i.severity = 'Medium' THEN 3
                WHEN i.severity = 'Low' THEN 1
                ELSE 0 
            END
        ) AS risk_score
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    GROUP BY t.destination_id
)
SELECT 
    d.name AS Kierunek,
    COALESCE(tpd.total_trips, 0) AS Liczba_wypraw,
    COALESCE(wi.risk_score, 0) AS Suma_punktow_ryzyka,
    COALESCE(wi.risk_score / tpd.total_trips, 0) AS Wazony_wspolczynnik_ryzyka
FROM 
    destinations d
LEFT JOIN 
    trips_per_destination tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    weighted_incidents wi ON d.destination_id = wi.destination_id
WHERE
    tpd.total_trips > 0
ORDER BY 
    Wazony_wspolczynnik_ryzyka DESC;
"""
```

```{python}
df_risk = pd.read_sql(query_weighted_risk, engine)
display(df_risk.style.format('{:.2f}', subset=['Wazony_wspolczynnik_ryzyka'])\
                 .format('{:,.0f}', subset=['Liczba_wypraw', 'Suma_punktow_ryzyka'])\
                 .background_gradient(cmap='Reds', subset=['Wazony_wspolczynnik_ryzyka'])\
                 .set_caption("Tabela 2: Ranking Ryzyka Destynacji (WskaÅºnik waÅ¼ony)"))
```

```{python}
most_risky = df_risk.iloc[0]
least_risky = df_risk.iloc[-1]

wniosek_markdown = f"""
### Podsumowanie Ryzyka Destynacji
<p>Nasz waÅ¼ony wskaÅºnik pozwala na obiektywnÄ… ocenÄ™ i priorytetyzacjÄ™ dziaÅ‚aÅ„ mitygujÄ…cych ryzyko.</p>
<ul>
    <li><span style="font-size: 1.5em;"></span> <b>NajwyÅ¼sze ryzyko:</b> DestynacjÄ… o najwyÅ¼szym wskaÅºniku ryzyka jest <b>{most_risky['Kierunek']}</b> z wynikiem <b>{most_risky['Wazony_wspolczynnik_ryzyka']:.2f} pkt</b> na wyprawÄ™. Sugeruje to koniecznoÅ›Ä‡ przeglÄ…du procedur bezpieczeÅ„stwa dla tej trasy.</li>
    <li><span style="font-size: 1.5em;"></span> <b>NajniÅ¼sze ryzyko:</b> NajbezpieczniejszÄ… z naszych popularnych destynacji okazaÅ‚/a siÄ™ <b>{least_risky['Kierunek']}</b> ({least_risky['Wazony_wspolczynnik_ryzyka']:.2f} pkt/wyprawÄ™). Praktyki stosowane na tej trasie mogÄ… stanowiÄ‡ wzÃ³r dla innych.</li>
</ul>
"""
display(Markdown(wniosek_markdown))
```

### Ryzyko zwiÄ…zane ze sprzÄ™tem
Nawet najbezpieczniejsza trasa staje siÄ™ ryzykowna, jeÅ›li statek kosmiczny jest zawodny. W tej czÄ™Å›ci analizujemy dane dotyczÄ…ce awarii sprzÄ™tu (category = 'equipment') w naszej flocie, aby zidentyfikowaÄ‡ jednostki wymagajÄ…ce szczegÃ³lnej uwagi serwisowej. PoniÅ¼szy wykres szereguje statki wedÅ‚ug wskaÅºnika "usterki na wyprawÄ™".

```{python}
#| include: false
#| echo: false
query_spacecraft_incidents = """
SELECT 
    spacecraft.name AS nazwa_statku,
    COUNT(*) AS liczba_usterek
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    spacecraft
ON
    trips.spacecraft_id = spacecraft.spacecraft_id
WHERE incidents.category = 'equipment'
GROUP BY spacecraft.name
ORDER BY liczba_usterek desc

"""
```

```{python}
#| include: false
#| echo: false
df_spacecrafts_incidents = pd.read_sql(query_spacecraft_incidents, engine)
print(df_spacecrafts_incidents.to_string())
```

```{python}
query_failure_rate = """
WITH trips_per_spacecraft AS (
    SELECT 
        spacecraft_id, 
        COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY spacecraft_id
),
equipment_failures AS (
    SELECT 
        t.spacecraft_id, 
        COUNT(i.incident_id) AS total_failures
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    WHERE i.category = 'equipment'
    GROUP BY t.spacecraft_id
)
SELECT
    s.name AS nazwa_statku,
    COALESCE(tps.total_trips, 0) AS liczba_wypraw,
    COALESCE(ef.total_failures, 0) AS liczba_usterek,
    CASE
        WHEN tps.total_trips > 0 THEN COALESCE(ef.total_failures, 0) / CAST(tps.total_trips AS FLOAT)
        ELSE 0
    END AS usterki_na_wyprawe
FROM
    spacecraft s
LEFT JOIN
    trips_per_spacecraft tps ON s.spacecraft_id = tps.spacecraft_id
LEFT JOIN
    equipment_failures ef ON s.spacecraft_id = ef.spacecraft_id
ORDER BY
    usterki_na_wyprawe DESC;
"""
```

```{python}
df_failure_rate = pd.read_sql(query_failure_rate, engine)
```

```{python}
df_plot = df_failure_rate.sort_values('usterki_na_wyprawe', ascending=True).copy()
df_plot['Status'] = np.where(df_plot['usterki_na_wyprawe'] > 0, 'WystÄ…piÅ‚y usterki', 'Brak usterek')

fig = px.bar(
    df_plot,
    y='nazwa_statku',
    x='usterki_na_wyprawe',
    orientation='h',
    title='Usterki sprzÄ™towe naszej floty',
    labels={'nazwa_statku': 'Statek kosmiczny', 'usterki_na_wyprawe': 'Åšrednia liczba usterek na wyprawÄ™'},
    color='Status',
    color_discrete_map={
        'WystÄ…piÅ‚y usterki': '#e74c3c',
        'Brak usterek': '#dfe6e9'
    },
    height=600
)

fig.update_traces(
    texttemplate='%{x:.3f}',
    textposition='outside'
)

max_value = df_plot['usterki_na_wyprawe'].max()
fig.update_xaxes(range=[0, max_value * 1.15])

fig.update_layout(
    showlegend=False,
    plot_bgcolor='white',
    xaxis_gridcolor='#ecf0f1'
)
fig.show()
```

```{python}
#| include: false
#| echo: false
print("--- Ranking NiezawodnoÅ›ci StatkÃ³w (Usterki na WyprawÄ™) ---")
print(df_failure_rate.to_string())
plt.figure(figsize=(12, 6))
sns.barplot(data=df_failure_rate, x='usterki_na_wyprawe', y='nazwa_statku', hue="nazwa_statku", palette='Reds_r')
plt.title('WskaÅºnik Usterek SprzÄ™towych na WyprawÄ™')
plt.xlabel('Åšrednia liczba usterek na jednÄ… wyprawÄ™')
plt.ylabel('Statek kosmiczny')
plt.tight_layout()
plt.show()
```


```{python}
most_failure_prone = df_failure_rate.iloc[0]
zero_failure_ships = df_failure_rate[df_failure_rate['usterki_na_wyprawe'] == 0]
count_zero_failure = len(zero_failure_ships)

wniosek_markdown = """
### Ocena NiezawodnoÅ›ci Floty
<p>Analiza wskaÅºnika usterek pozwala na precyzyjne planowanie przeglÄ…dÃ³w serwisowych i alokacjÄ™ budÅ¼etu na utrzymanie floty.</p>
<ul>
"""

liczba_usterek_prone = int(most_failure_prone['liczba_usterek'])
liczba_wypraw_prone = int(most_failure_prone['liczba_wypraw'])

wniosek_markdown += f"""
<li><b>Wymaga uwagi:</b> Najbardziej podatny na usterki sprzÄ™towe jest statek <b>{most_failure_prone['nazwa_statku']}</b>. 
Odnotowuje on Å›rednio <b>{most_failure_prone['usterki_na_wyprawe']:.3f} usterki</b> na kaÅ¼dÄ… odbytÄ… wyprawÄ™. <br>
<small style="color: #6c757d;"><i>(Na podstawie {liczba_usterek_prone} usterek w ciÄ…gu {liczba_wypraw_prone} wypraw)</i></small>
</li>
"""

workhorse_champion = zero_failure_ships.sort_values('liczba_wypraw', ascending=False).iloc[0]
liczba_wypraw_champion = int(workhorse_champion['liczba_wypraw'])

wniosek_markdown += f"""
<li><b>WzÃ³r niezawodnoÅ›ci:</b> AÅ¼ <b>{count_zero_failure} jednostek</b> w naszej flocie zakoÅ„czyÅ‚o wszystkie misje w analizowanym okresie bez Å¼adnej usterki sprzÄ™towej.
Na szczegÃ³lne wyrÃ³Å¼nienie zasÅ‚uguje <b>{workhorse_champion['nazwa_statku']}</b>, ktÃ³ry jest najczÄ™Å›ciej eksploatowanÄ… jednostkÄ… w tej grupie.<br>
<small style="color: #6c757d;"><i>(WykonaÅ‚ bezawaryjnie aÅ¼ {liczba_wypraw_champion} misji)</i></small>
</li>
"""
wniosek_markdown += "</ul>"

display(Markdown(wniosek_markdown))
```

## WpÅ‚yw incydentÃ³w na satysfakcjÄ™ klienta

W tej czÄ™Å›ci analizy Å‚Ä…czymy "twarde" dane operacyjne z "miÄ™kkimi" danymi dotyczÄ…cymi odczuÄ‡ naszych pasaÅ¼erÃ³w. Stawiamy fundamentalne pytanie: czy liczba incydentÃ³w zarejestrowanych podczas wyprawy ma statystycznie istotny wpÅ‚yw na jej koÅ„cowÄ… ocenÄ™?

Intuicja podpowiada, Å¼e kaÅ¼da, nawet drobna usterka czy incydent, moÅ¼e negatywnie wpÅ‚ynÄ…Ä‡ na postrzeganie caÅ‚ej, skÄ…dinÄ…d udanej, wyprawy. Potwierdzenie lub obalenie tej tezy ma kluczowe znaczenie dla zrozumienia, jak krytyczne jest zapewnienie bezproblemowego przebiegu misji nie tylko dla bezpieczeÅ„stwa, ale i dla reputacji oraz siÅ‚y naszej marki.

PoniÅ¼szy wykres punktowy przedstawia zaleÅ¼noÅ›Ä‡ miÄ™dzy Å›redniÄ… ocenÄ… danej wyprawy a liczbÄ… odnotowanych w jej trakcie incydentÃ³w. Czerwona linia trendu wizualizuje ogÃ³lnÄ… tendencjÄ™ tej zaleÅ¼noÅ›ci.

```{python}
#| include: false
#| echo: false
query_feedback_incidents = """
SELECT 
    AVG(feedback.rating) AS srednia_ocena,
    t.liczba_wypadkow
FROM
    feedback
LEFT JOIN
    trips
ON
    feedback.trip_id = trips.trip_id
LEFT JOIN
    (SELECT
    incidents.trip_id, 
    COUNT(incidents.incident_id) AS liczba_wypadkow
    FROM incidents
    GROUP BY trip_id) t
ON
    t.trip_id = trips.trip_id
GROUP BY 
    feedback.trip_id
"""
```

```{python}
query_correlation = """
WITH avg_ratings AS (
    SELECT trip_id, AVG(rating) AS avg_rating
    FROM feedback
    GROUP BY trip_id
),
incident_counts AS (
    SELECT trip_id, COUNT(incident_id) AS incident_count
    FROM incidents
    GROUP BY trip_id
)
SELECT 
    t.trip_id,
    ar.avg_rating AS srednia_ocena,
    COALESCE(ic.incident_count, 0) AS liczba_incydentow
FROM 
    trips t
JOIN 
    avg_ratings ar ON t.trip_id = ar.trip_id
LEFT JOIN 
    incident_counts ic ON t.trip_id = ic.trip_id;
"""
```

```{python}
df_correlation = pd.read_sql(query_correlation, engine)
```

```{python}
fig = px.scatter(
    df_correlation,
    x='liczba_incydentow',
    y='srednia_ocena',
    title='ZaleÅ¼noÅ›Ä‡ Oceny Wyprawy od Liczby IncydentÃ³w',
    labels={
        'liczba_incydentow': 'Liczba incydentÃ³w podczas wyprawy',
        'srednia_ocena': 'Åšrednia ocena wyprawy (1-5)'
    },
    trendline='ols',
    trendline_color_override='#e74c3c'
)

fig.update_layout(
    plot_bgcolor='white',
    xaxis_gridcolor='#ecf0f1',
    yaxis_gridcolor='#ecf0f1'
)
max_incidents = int(df_correlation['liczba_incydentow'].max())
fig.update_xaxes(
    dtick=1,
    range=[-0.5, max_incidents + 0.5]
)
fig.show()
```

```{python}
correlation_coeff = df_correlation['srednia_ocena'].corr(df_correlation['liczba_incydentow'])

# Logika wnioskÃ³w
if correlation_coeff < -0.5:
    wniosek = "Istnieje silna korelacja ujemna."
    szczegoly = "Wzrost liczby incydentÃ³w jest silnie powiÄ…zany ze spadkiem Å›redniej oceny wyprawy."
elif correlation_coeff < -0.2:
    wniosek = "Istnieje zauwaÅ¼alna korelacja ujemna."
    szczegoly = "Wzrost liczby incydentÃ³w ma tendencjÄ™ do obniÅ¼ania Å›redniej oceny wyprawy."
else:
    wniosek = "Brak silnej korelacji."
    szczegoly = "Liczba incydentÃ³w nie wydaje siÄ™ mieÄ‡ decydujÄ…cego wpÅ‚ywu na ocenÄ™ koÅ„cowÄ…. Klienci prawdopodobnie biorÄ… pod uwagÄ™ inne czynniki, takie jak widoki, jakoÅ›Ä‡ obsÅ‚ugi czy profesjonalizm zaÅ‚ogi w radzeniu sobie z incydentem."

```

```{python}
analiza_markdown = f"""
### Analiza korelacji
<p>Obliczony wspÃ³Å‚czynnik korelacji Pearsona dla badanych zmiennych wynosi: <b>{correlation_coeff:.3f}</b>.</p>
<p style="font-size: 1.1em;"><b>Wniosek:</b> {wniosek}</p>
<p>{szczegoly}</p>
"""

display(Markdown(analiza_markdown))
```
```{python}
#| include: false
#| echo: false
correlation_coeff = df_correlation['srednia_ocena'].corr(df_correlation['liczba_incydentow'])

print(f"--- ğŸ¤– Analiza korelacji: Ocena vs. Incydenty ---")
print(f"Obliczony wspÃ³Å‚czynnik korelacji: {correlation_coeff:.3f}")

if correlation_coeff < -0.3:
    print("Wniosek: Istnieje zauwaÅ¼alna korelacja ujemna. Wzrost liczby incydentÃ³w wiÄ…Å¼e siÄ™ ze spadkiem ocen.")
elif correlation_coeff > 0.3:
     print("Wniosek: Istnieje zauwaÅ¼alna korelacja dodatnia (wynik nieoczekiwany).")
else:
    print("Wniosek: Brak silnej korelacji. Liczba incydentÃ³w nie wydaje siÄ™ mieÄ‡ duÅ¼ego wpÅ‚ywu na ocenÄ™.")
print("-------------------------------------------------")
plt.figure(figsize=(10, 6))
sns.regplot(data=df_correlation, x='liczba_incydentow', y='srednia_ocena',
            line_kws={"color": "red", "lw": 2}, scatter_kws={"alpha": 0.6})

plt.title('ZaleÅ¼noÅ›Ä‡ Å›redniej oceny od liczby incydentÃ³w na wyprawie', fontsize=15)
plt.xlabel('Liczba incydentÃ³w podczas wyprawy')
plt.ylabel('Åšrednia ocena wyprawy')
max_incidents = int(df_correlation['liczba_incydentow'].max())
plt.xticks(range(max_incidents + 1))
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

## GÅ‚os klienta - analiza ocen wypraw

Po analizie wskaÅºnikÃ³w operacyjnych i finansowych, nadszedÅ‚ czas, aby wsÅ‚uchaÄ‡ siÄ™ w najwaÅ¼niejszy gÅ‚os w naszym biznesie â€“ gÅ‚os klienta. Oceny wystawiane po kaÅ¼dej wyprawie sÄ… bezcennym ÅºrÃ³dÅ‚em informacji o naszych mocnych i sÅ‚abych stronach. W tej sekcji zidentyfikujemy, ktÃ³re elementy naszej oferty sÄ… najbardziej doceniane, a ktÃ³re wymagajÄ… naszej uwagi.

Analiza opiera siÄ™ na wszystkich zebranych ocenach, z wyÅ‚Ä…czeniem destynacji i typÃ³w wypraw z maÅ‚Ä… liczbÄ… opinii (poniÅ¼ej 3), aby zapewniÄ‡ statystycznÄ… istotnoÅ›Ä‡ wynikÃ³w.

### Ranking ocen destynacji

Pierwszym krokiem jest zrozumienie, ktÃ³re lokalizacje w UkÅ‚adzie SÅ‚onecznym dostarczajÄ… naszym pasaÅ¼erom najlepszych wraÅ¼eÅ„. PoniÅ¼szy wykres szereguje nasze destynacje od najniÅ¼ej do najwyÅ¼ej ocenianych.

```{python}
query_dest_ratings = """
SELECT
    d.name AS kierunek,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE f.rating IS NOT NULL
GROUP BY
    d.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_dest_ratings = pd.read_sql(query_dest_ratings, engine)
```

```{python}
fig_dest = px.bar(
    df_dest_ratings,
    x='srednia_ocena',
    y='kierunek',
    orientation='h',
    title='Ranking Åšrednich Ocen dla PoszczegÃ³lnych Destynacji',
    labels={'srednia_ocena': 'Åšrednia ocena (w skali 1-5)', 'kierunek': 'Destynacja'},
    color='srednia_ocena',
    color_continuous_scale='Plasma',
    text='srednia_ocena',
    height=500
)
fig_dest.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig_dest.update_layout(xaxis=dict(range=[0, 5.2]), plot_bgcolor='white', yaxis={'categoryorder':'total ascending'})
fig_dest.update_coloraxes(showscale=False)
fig_dest.show()
```

```{python}
best_dest = df_dest_ratings.iloc[0]
worst_dest = df_dest_ratings.iloc[1]

wniosek_markdown = f"""
### Podsumowanie ocen destynacji
<p>Analiza ocen pozwala zidentyfikowaÄ‡ nasze "pereÅ‚ki" oraz obszary wymagajÄ…ce poprawy doÅ›wiadczeÅ„ klienta.</p>
<ul>
    <li><b>NajwyÅ¼ej oceniana:</b> DestynacjÄ…, ktÃ³ra dostarcza naszym klientom najwiÄ™cej satysfakcji, jest <b>{best_dest['kierunek']}</b> ze Å›redniÄ… ocenÄ… <b>{best_dest['srednia_ocena']:.2f}</b> (na podstawie {int(best_dest['liczba_ocen'])} opinii).</li>
    <li style="margin-top: 15px;"><b>Wymaga uwagi:</b> NajniÅ¼sze oceny otrzymuje <b>{worst_dest['kierunek']}</b> (Å›rednia <b>{worst_dest['srednia_ocena']:.2f}</b> z {int(worst_dest['liczba_ocen'])} opinii). Rekomendujemy analizÄ™ feedbacku z tej trasy w celu identyfikacji przyczyn niÅ¼szej satysfakcji.</li>
</ul>
"""
display(Markdown(wniosek_markdown))
```

```{python}
#| include: false
#| echo: false

print("\n--- â­ Ranking Ocen Destynacji ---")

best_dest = df_dest_ratings.iloc[0]
worst_dest = df_dest_ratings.iloc[-1]

print(f"\nğŸ¥‡ NajwyÅ¼ej oceniana destynacja: '{best_dest['kierunek']}'")
print(f"   -> Åšrednia ocena: {best_dest['srednia_ocena']:.2f} na podstawie {int(best_dest['liczba_ocen'])} opinii.")

print(f"\nğŸ“‰ NajniÅ¼ej oceniana destynacja: '{worst_dest['kierunek']}'")
print(f"   -> Åšrednia ocena: {worst_dest['srednia_ocena']:.2f} na podstawie {int(worst_dest['liczba_ocen'])} opinii.")

```

```{python}
#| include: false
#| echo: false

plt.figure(figsize=(12, 7))
sns.barplot(data=df_dest_ratings, x='srednia_ocena', y='kierunek', palette='coolwarm')
plt.title('Ranking Å›rednich ocen dla poszczegÃ³lnych destynacji', fontsize=15)
plt.xlabel('Åšrednia ocena (w skali 1-5)')
plt.ylabel('Destynacja')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

### Ranking ocen rodzajÃ³w wypraw

NastÄ™pnie sprawdzamy, ktÃ³re typy misji â€“ niezaleÅ¼nie od celu podrÃ³Å¼y â€“ sÄ… najlepiej odbierane przez pasaÅ¼erÃ³w. To pozwala nam oceniÄ‡, czy nasze "opakowanie" produktu (luksusowe, badawcze, ekstremalne itd.) trafia w gusta klientÃ³w.

```{python}
query_type_ratings = """
SELECT
    tt.name AS typ_wyprawy,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    trip_types tt ON t.trip_type_id = tt.trip_type_id
WHERE f.rating IS NOT NULL
GROUP BY
    tt.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_type_ratings = pd.read_sql(query_type_ratings, engine)
```
```{python}
fig_type = px.bar(
    df_type_ratings,
    x='srednia_ocena',
    y='typ_wyprawy',
    orientation='h',
    title='Ranking Åšrednich Ocen dla RodzajÃ³w Wypraw',
    labels={'srednia_ocena': 'Åšrednia ocena (w skali 1-5)', 'typ_wyprawy': 'Rodzaj wyprawy'},
    color='srednia_ocena',
    color_continuous_scale='Viridis',
    text='srednia_ocena',
    height=500
)
fig_type.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig_type.update_layout(xaxis=dict(range=[0, 5.2]), plot_bgcolor='white', yaxis={'categoryorder':'total ascending'})
fig_type.update_coloraxes(showscale=False)
fig_type.show()
```

```{python}
best_type = df_type_ratings.iloc[0]
worst_type = df_type_ratings.iloc[-1]

wniosek_markdown_2 = f"""
### Podsumowanie ocen rodzajÃ³w wypraw
<ul>
    <li><b>Ulubiony typ wyprawy:</b> Klienci najwyÅ¼ej oceniajÄ… format <b>{best_type['typ_wyprawy']}</b>, przyznajÄ…c mu Å›redniÄ… ocenÄ™ <b>{best_type['srednia_ocena']:.2f}</b> (na podstawie {int(best_type['liczba_ocen'])} opinii). Warto inwestowaÄ‡ w promocjÄ™ tego segmentu.</li>
    <li style="margin-top: 15px;"><b>Do przemyÅ›lenia:</b> NajwiÄ™ksze wyzwanie stanowi format <b>{worst_type['typ_wyprawy']}</b> (Å›rednia <b>{worst_type['srednia_ocena']:.2f}</b> z {int(worst_type['liczba_ocen'])} opinii). NaleÅ¼y zastanowiÄ‡ siÄ™, czy oczekiwania klientÃ³w wobec tego typu wypraw sÄ… w peÅ‚ni zaspokajane.</li>
</ul>
"""
display(Markdown(wniosek_markdown_2))
```
```{python}
#| include: false
#| echo: false

print("\n--- â­ Ranking Ocen RodzajÃ³w Wypraw ---")
best_type = df_type_ratings.iloc[0]
worst_type = df_type_ratings.iloc[-1]

print(f"\nğŸ¥‡ NajwyÅ¼ej oceniany typ wyprawy: '{best_type['typ_wyprawy']}'")
print(f"   -> Åšrednia ocena: {best_type['srednia_ocena']:.2f} na podstawie {int(best_type['liczba_ocen'])} opinii.")

print(f"\nğŸ“‰ NajniÅ¼ej oceniany typ wyprawy: '{worst_type['typ_wyprawy']}'")
print(f"   -> Åšrednia ocena: {worst_type['srednia_ocena']:.2f} na podstawie {int(worst_type['liczba_ocen'])} opinii.")
```

```{python}
#| include: false
#| echo: false

plt.figure(figsize=(12, 7))
sns.barplot(data=df_type_ratings, x='srednia_ocena', y='typ_wyprawy', palette='viridis')
plt.title('Ranking Å›rednich ocen dla poszczegÃ³lnych rodzajÃ³w wypraw', fontsize=15)
plt.xlabel('Åšrednia ocena (w skali 1-5)')
plt.ylabel('Rodzaj wyprawy')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

## Profil demograficzny klientÃ³w - analiza wieku

Zrozumienie, "kim" jest nasz klient, jest rÃ³wnie waÅ¼ne, jak wiedza, "dokÄ…d" chce podrÃ³Å¼owaÄ‡. Wiek jest jednym z fundamentalnych wymiarÃ³w demograficznych, ktÃ³ry wpÅ‚ywa na preferencje, moÅ¼liwoÅ›ci finansowe oraz styl komunikacji. Analiza struktury wiekowej naszej bazy klientÃ³w pozwala nam zweryfikowaÄ‡, czy nasza oferta trafia do zamierzonej grupy docelowej i gdzie leÅ¼Ä… potencjalne, niewykorzystane jeszcze segmenty rynku.

PoniÅ¼sza analiza opiera siÄ™ na datach urodzenia wszystkich naszych zarejestrowanych klientÃ³w.

```{python}
query_dob = """
SELECT date_of_birth
FROM clients
WHERE date_of_birth IS NOT NULL;
"""
```

```{python}
df_dob = pd.read_sql(query_dob, engine)
```

```{python}
today_real = date.today()
df_dob['age'] = df_dob['date_of_birth'].apply(
    lambda dob: (today_real - dob).days / 365.25
) + 100
df_dob['age'] = df_dob['age'].astype(int)
```

```{python}
fig = px.histogram(
    df_dob,
    x='age',
    nbins=25,
    title='RozkÅ‚ad Wieku KlientÃ³w Space-U',
    labels={'age': 'Wiek klienta (w latach)', 'count': 'Liczba klientÃ³w'},
    marginal='rug',
    template='plotly_white',
    histnorm='percent'
)
fig.update_layout(
    yaxis_title='UdziaÅ‚ procentowy klientÃ³w',
    bargap=0.1,
    plot_bgcolor='white',
    yaxis_ticksuffix='%'
)
fig.update_traces(
    marker_color='#3498db',
    hovertemplate='Wiek: %{x}<br>UdziaÅ‚: %{y:.2f}%'
)
fig.show()
```

```{python}
stats = df_dob['age'].describe()

# Budowanie bloku Markdown
analiza_markdown = f"""
### Kluczowe Statystyki Wieku
<p>PoniÅ¼sze dane charakteryzujÄ… typowego klienta Space-U pod wzglÄ™dem wieku.</p>
<ul>
<li><b>Åšredni wiek:</b> {stats['mean']:.1f} lat</li>
<li><b>Mediana (wiek Å›rodkowy):</b> {stats['50%']:.0f} lat</li>
<li><b>PrzedziaÅ‚ wiekowy:</b> od {stats['min']:.0f} do {stats['max']:.0f} lat</li>
<li><b>Odchylenie standardowe:</b> {stats['std']:.1f} lat</li>
</ul>
<p><b>Wnioski biznesowe:</b> Nasza baza klientÃ³w jest wyraÅºnie skoncentrowana wokÃ³Å‚ osÃ³b w wieku <b>od {stats['25%']:.0f} do {stats['75%']:.0f} lat</b> (Å›rodkowe 50% klientÃ³w), co sugeruje, Å¼e nasza oferta najsilniej rezonuje z osobami o ustabilizowanej pozycji zawodowej i finansowej. Niskie odchylenie standardowe potwierdza tÄ™ silnÄ… koncentracjÄ™. Warto rozwaÅ¼yÄ‡ stworzenie dedykowanych kampanii lub produktÃ³w skierowanych do mÅ‚odszych i starszych grup demograficznych, ktÃ³re sÄ… obecnie sÅ‚abiej reprezentowane.</p>"""

display(Markdown(analiza_markdown))
```

```{python}
#| include: false
#| echo: false
print("\n--- ğŸ“Š Statystyki Wieku KlientÃ³w ---")
print(df_dob['age'].describe().round(2).to_string())
print("\n------------------------------------")

plt.figure(figsize=(12, 7))
sns.histplot(data=df_dob, x='age', bins=20, kde=True, color='dodgerblue')

plt.title('RozkÅ‚ad wieku klientÃ³w', fontsize=16)
plt.xlabel('Wiek (w latach)', fontsize=12)
plt.ylabel('Liczba klientÃ³w', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.show()
```

## Segmentacja klientÃ³w metodÄ… RFM

Analiza RFM (Recency, Frequency, Monetary) to sprawdzona i potÄ™Å¼na technika marketingowa sÅ‚uÅ¼Ä…ca do segmentacji bazy klientÃ³w. Zamiast traktowaÄ‡ wszystkich klientÃ³w jednakowo, grupujemy ich na podstawie ich zachowaÅ„ transakcyjnych, odpowiadajÄ…c na trzy kluczowe pytania:

* **Recency** (Kiedy ostatnio podrÃ³Å¼owali?) - Jak niedawno klient skorzystaÅ‚ z naszych usÅ‚ug? Im niÅ¼sza wartoÅ›Ä‡, tym lepiej.

* **Frequency** (Jak czÄ™sto podrÃ³Å¼ujÄ…?) - Jak czÄ™sto klient do nas wraca? Im wyÅ¼sza wartoÅ›Ä‡, tym lepiej.

* **Monetary** (Ile wydajÄ…?) - Jaka jest Å‚Ä…czna wartoÅ›Ä‡ wszystkich transakcji danego klienta? Im wyÅ¼sza wartoÅ›Ä‡, tym lepiej.

DziÄ™ki tej analizie moÅ¼emy zidentyfikowaÄ‡ naszych najcenniejszych klientÃ³w ("MistrzÃ³w"), tych, o ktÃ³rych musimy zawalczyÄ‡ ("Ryzykowni"), oraz tych, ktÃ³rzy dopiero rozpoczynajÄ… swojÄ… przygodÄ™ ze Space-U ("Nowi Klienci"). To fundament pod budowÄ™ skutecznych, spersonalizowanych kampanii i strategii utrzymania klienta.

### RozkÅ‚ad klientÃ³w w segmentach RFM

PoniÅ¼szy wykres przedstawia wielkoÅ›Ä‡ poszczegÃ³lnych segmentÃ³w w naszej bazie klientÃ³w.
```{python}
today_real = date.today()
future_analysis_date = today_real.replace(year=today_real.year + 100)
analysis_date = future_analysis_date.strftime('%Y-%m-%d')

query_rfm = f"""
WITH Monetary AS (
    SELECT
        client_id,
        SUM(amount) AS monetary_value
    FROM transactions
    WHERE 
        status = 'Completed' AND
        transaction_date <= '{analysis_date}'
    GROUP BY client_id
),
RecencyFrequency AS (
    SELECT
        p.client_id,
        MAX(t.departure_datetime) AS last_trip_date,
        COUNT(DISTINCT p.trip_id) AS frequency
    FROM trip_participants p
    JOIN trips t ON p.trip_id = t.trip_id
    WHERE 
        t.departure_datetime <= '{analysis_date}'
    GROUP BY p.client_id
)
SELECT
    c.client_id,
    c.first_name,
    c.last_name,
    DATEDIFF('{analysis_date}', rf.last_trip_date) AS recency_days,
    COALESCE(rf.frequency, 0) AS frequency,
    COALESCE(m.monetary_value, 0) AS monetary
FROM
    clients c
LEFT JOIN
    RecencyFrequency rf ON c.client_id = rf.client_id
LEFT JOIN
    Monetary m ON c.client_id = m.client_id;
"""

df_rfm = pd.read_sql(query_rfm, engine)
df_rfm.fillna({'recency_days': 9999}, inplace=True)

df_rfm['R_score'] = 4 - pd.qcut(df_rfm['recency_days'], q=4, labels=False, duplicates='drop')
df_rfm['F_score'] = pd.qcut(df_rfm['frequency'].rank(method='first'), q=4, labels=False, duplicates='drop') + 1
df_rfm['M_score'] = pd.qcut(df_rfm['monetary'].rank(method='first'), q=4, labels=False, duplicates='drop') + 1

df_rfm = df_rfm.astype({'R_score': 'int64', 'F_score': 'int64', 'M_score': 'int64'})

def assign_segment(row):
    if row['R_score'] >= 4 and row['F_score'] >= 4: return 'Mistrzowie (Champions)'
    if row['R_score'] >= 3 and row['F_score'] >= 3: return 'Lojalni Klienci'
    if row['R_score'] <= 2 and row['F_score'] >= 3: return 'Ryzykowni (At Risk)'
    if row['R_score'] >= 3 and row['M_score'] >= 4: return 'Wieloryby (Big Spenders)'
    if row['R_score'] == 4 and row['F_score'] == 1: return 'Nowi Klienci'
    if row['R_score'] <= 2 and row['F_score'] <= 2: return 'HibernujÄ…cy'
    return 'Pozostali'

df_rfm['Segment'] = df_rfm.apply(assign_segment, axis=1)
segment_counts = df_rfm['Segment'].value_counts()
```
```{python}
fig = px.bar(
    x=segment_counts.index,
    y=segment_counts.values,
    title='RozkÅ‚ad KlientÃ³w w Segmentach RFM',
    labels={'y': 'Liczba KlientÃ³w', 'x': 'Segment'},
    text=segment_counts.values,
    color=segment_counts.values,
    color_continuous_scale='Plasma'
)
fig.update_traces(textposition='outside')
fig.update_layout(plot_bgcolor='white', xaxis_tickangle=-45)
fig.update_coloraxes(showscale=False)
fig.show()
```
```{python}

#| include: false
#| echo: false

print(f"--- ğŸ“Š Analiza RFM (stan na dzieÅ„: {analysis_date}) ---")
print("\nPrzykÅ‚adowe dane po segmentacji:")
print(df_rfm[['first_name', 'last_name', 'recency_days', 'frequency', 'monetary', 'R_score', 'F_score', 'M_score', 'Segment']].head().to_string())
print("\n" + "="*50 + "\n")

plt.figure(figsize=(12, 8))
segment_counts = df_rfm['Segment'].value_counts()
sns.barplot(x=segment_counts.index, y=segment_counts.values, palette='viridis')
plt.title('RozkÅ‚ad KlientÃ³w w Segmentach RFM', fontsize=16)
plt.xlabel('Segment', fontsize=12)
plt.ylabel('Liczba KlientÃ³w', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
segment_counts = df_rfm['Segment'].value_counts()
total_clients = len(df_rfm)

recommendations = {
    'Mistrzowie (Champions)': 
        "To Twoi najcenniejsi klienci. AngaÅ¼uj ich, proÅ› o opinie i recenzje, "
        "zaoferuj programy lojalnoÅ›ciowe i dostÄ™p do ekskluzywnych ofert. "
        "SÄ… ambasadorami Twojej marki.",
        
    'Lojalni Klienci': 
        "SÄ… krÄ™gosÅ‚upem Twojej firmy. Podtrzymuj ich zaangaÅ¼owanie, oferujÄ…c "
        "nowe produkty (cross-selling), lepsze wersje wypraw (up-selling) "
        "i budujÄ…c z nimi dÅ‚ugotrwaÅ‚Ä… relacjÄ™.",

    'Ryzykowni (At Risk)': 
        "KLUCZOWA GRUPA DO REAKTYWACJI! To byli dobrzy klienci, ktÃ³rzy dawno "
        "nic nie kupili. Skontaktuj siÄ™ z nimi osobiÅ›cie, zaoferuj spersonalizowanÄ… "
        "zniÅ¼kÄ™ 'na powrÃ³t' i dowiedz siÄ™, dlaczego przestali podrÃ³Å¼owaÄ‡.",

    'Wieloryby (Big Spenders)':
        "WydajÄ… duÅ¼o, ale niekoniecznie czÄ™sto. Upewnij siÄ™, Å¼e sÄ… zadowoleni "
        "z jakoÅ›ci usÅ‚ug. MogÄ… byÄ‡ podatni na oferty konkurencji. Warto zadbaÄ‡ "
        "o ich satysfakcjÄ™.",

    'Nowi Klienci':
        "Pierwsze wraÅ¼enie jest kluczowe. Zapewnij im doskonaÅ‚e doÅ›wiadczenie "
        "na pokÅ‚adzie i stwÃ³rz spersonalizowanÄ… Å›cieÅ¼kÄ™ komunikacji (np. seria maili), "
        "aby zachÄ™ciÄ‡ ich do drugiej podrÃ³Å¼y i zamieniÄ‡ w lojalnych klientÃ³w.",
        
    'HibernujÄ…cy':
        "DuÅ¼a grupa nieaktywnych klientÃ³w. JeÅ›li ich liczba jest znaczÄ…ca, rozwaÅ¼ "
        "szeroko zakrojonÄ…, ale niskokosztowÄ… kampaniÄ™ 'TÄ™sknimy za TobÄ…!' z atrakcyjnÄ… "
        "ofertÄ…. Nie inwestuj w nich tyle, co w segment 'Ryzykowni'."
}

```

```{python}
rekomendacje_markdown = "### Kluczowe Segmenty i Rekomendacje Strategiczne\n"

# W pÄ™tli tworzymy osobny blok "Callout" dla kaÅ¼dego segmentu
for segment, count in segment_counts.items():
    if segment in recommendations:
        percentage = (count / total_clients) * 100
        
        # Tworzymy blok "Callout" w skÅ‚adni Quarto Markdown
        # WaÅ¼ne: CaÅ‚oÅ›Ä‡ jest w jednym f-stringu bez wciÄ™Ä‡, aby uniknÄ…Ä‡ bÅ‚Ä™dÃ³w formatowania
        rekomendacje_markdown += f"""
::: {{.callout-note icon=false}}
#### {segment}

**{count} klientÃ³w** ({percentage:.1f}% wszystkich)

**Rekomendacja strategiczna:** {recommendations[segment]}
:::
"""

display(Markdown(rekomendacje_markdown))
```

## Wyprawy odpychajÄ…ce i przyciÄ…gajÄ…ce
W tej sekcji analizujemy wyprawy, po ktÃ³rych klienci najchÄ™tniej wracajÄ… oraz wyprawy po ktÃ³rych juÅ¼ wiÄ™cej ich nie widzimy. Rozbijemy ten problem na trzy czÄ™Å›ci, by mieÄ‡ lepszy wglÄ…d w sytuacjÄ™. Na poczÄ…tek przyjrzymy siÄ™ wyprawom, na ktÃ³rych byÅ‚o najwiÄ™cej klientÃ³w, co pojechali tylko raz. Chcemy siÄ™ dowiedzieÄ‡, jakie wyprawy polegÅ‚y w wywarciu dobrego wraÅ¼enia na nowych klientach. Otrzymamy informacjÄ™ o cechach wyprawy, a pÃ³Åºniej spojrzymy ktÃ³re z tych cech wystÄ™pujÄ… najczÄ™Å›ciej. Od gÃ³ry bÄ™dziemy wypisywaÄ‡ te loty, co miaÅ‚y najwiÄ™cej jednorazowych klientÃ³w.

```{python}
#| echo: false
#| include: false
def df_summary_markdown(df):
    summary_planeta = df['Planeta'].value_counts().reset_index()
    summary_planeta.columns = ['Planeta', 'liczba']

    summary_typ = df['Typ wyprawy'].value_counts().reset_index()
    summary_typ.columns = ['Typ wyprawy', 'liczba']

    summary_pojazd = df['Pojazd'].value_counts().reset_index()
    summary_pojazd.columns = ['Pojazd', 'liczba']

    markdown = "Podsumowanie \n"

    # ğŸŒ Planety
    if summary_planeta["liczba"][0] == 1:
        markdown += "<p>ğŸ”¸ Wszystkie planety wystÄ™pujÄ… rÃ³wnie czÄ™sto.</p>\n"
    else:
        markdown += (
            f"<p>ğŸŒ NajczÄ™Å›ciej wystÄ™pujÄ…ca planeta to <b>{summary_planeta['Planeta'][0]}</b> "
            f"z liczbÄ… <b>{summary_planeta['liczba'][0]}</b> wypraw.</p>\n"
        )

    # ğŸ§­ Typ wyprawy
    if summary_typ["liczba"][0] == 1:
        markdown += "<p>ğŸ”¸ Wszystkie rodzaje wycieczek wystÄ™pujÄ… rÃ³wnie czÄ™sto.</p>\n"
    else:
        markdown += (
            f"<p>ğŸ§­ NajczÄ™stszy rodzaj wycieczki to <b>{summary_typ['Typ wyprawy'][0]}</b> "
            f"({summary_typ['liczba'][0]} razy).</p>\n"
        )

    # ğŸš€ Pojazdy
    if summary_pojazd["liczba"][0] == 1:
        markdown += "<p>ğŸ”¸ Wszystkie pojazdy kosmiczne wystÄ™pujÄ… rÃ³wnie czÄ™sto.</p>\n"
    else:
        markdown += (
            f"<p>ğŸš€ NajczÄ™Å›ciej uÅ¼ywany pojazd kosmiczny to <b>{summary_pojazd['Pojazd'][0]}</b> "
            f"(uÅ¼yty {summary_pojazd['liczba'][0]} razy).</p>\n"
        )

    display(Markdown(markdown))
```
```{python}
query_one_timers = """
    SELECT 
        client_id, 
        COUNT(trip_id) as trips 
    FROM  trip_participants 
    GROUP BY client_id
    HAVING trips = 1
"""
df_one_time = pd.read_sql_query(text(query_one_timers), engine)
client_ids = df_one_time['client_id'].tolist()

# --- Krok 2: podrÃ³Å¼e tych klientÃ³w ---
if not client_ids:
    one_time_trips = []
else:
    placeholders = ','.join([':id'+str(i) for i in range(len(client_ids))])
    param_dict = {f'id{i}': cid for i, cid in enumerate(client_ids)}

    query_one_time_trips = f"""
        SELECT trip_id, COUNT(*) as count
        FROM trip_participants
        WHERE client_id IN ({placeholders})
        GROUP BY trip_id
        ORDER BY count DESC
    """
    df_trips = pd.read_sql_query(text(query_one_time_trips), engine, params=param_dict)
    trip_ids = df_trips['trip_id'].tolist()

# --- Krok 3: szczegÃ³Å‚y podrÃ³Å¼y ---
if not trip_ids:
    df_disliked_trips = pd.DataFrame(columns=["Planeta", "Typ wyprawy", "Pojazd", "Rakieta", "Id"])
else:
    placeholders = ','.join([':id'+str(i) for i in range(len(trip_ids))])
    param_dict = {f'id{i}': tid for i, tid in enumerate(trip_ids)}

    query_trip_info = f"""
        SELECT 
            d.name AS destination,
            tt.name AS trip_type,
            s.name AS spacecraft_name,
            r.name AS rocket_name,
            t.trip_id
        FROM trip_participants tp
        JOIN trips t ON tp.trip_id = t.trip_id
        JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
        JOIN rockets r ON t.rocket_id = r.rocket_id
        JOIN destinations d ON t.destination_id = d.destination_id
        JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
        WHERE tp.trip_id IN ({placeholders})
        GROUP BY t.trip_id, d.name, tt.name
    """
    df_disliked_trips = pd.read_sql_query(text(query_trip_info), engine, params=param_dict)

# --- Formatowanie koÅ„cowe ---
df_disliked_trips.columns = ["Planeta", "Typ wyprawy", "Pojazd", "Rakieta", "Id"]
df_disliked_trips.index = pd.RangeIndex(start=1, stop=len(df_disliked_trips)+1)

# WyÅ›wietlenie wynikÃ³w
display(df_disliked_trips.head(10))
df_summary_markdown(df_disliked_trips.head(10))
```

Teraz zbadamy wyprawy, ktÃ³re zniechÄ™ciÅ‚y klientÃ³w, ktÃ³rzy juÅ¼ kilka razy z nami latali. To da nam informacjÄ™, jakie typy wypraw zmÄ™czyÅ‚y lub znudziÅ‚y naszych pasaÅ¼erÃ³w.

```{python}
one_time_ids = df_one_time['client_id'].tolist()

if not one_time_ids:
    df = pd.DataFrame(columns=["client_id", "trip_id"])
else:
    one_time_ids = [int(t) for t in one_time_ids]
    placeholders = ','.join([f':id{i}' for i in range(len(one_time_ids))])
    param_dict = {f'id{i}': val for i, val in enumerate(one_time_ids)}

    query_last_trips = f"""
    SELECT
        tp.client_id,
        t.trip_id
    FROM
        trip_participants tp
    JOIN trips t ON tp.trip_id = t.trip_id
    WHERE
        tp.client_id NOT IN ({placeholders})
        AND t.departure_datetime = (
            SELECT MAX(t2.departure_datetime)
            FROM trip_participants tp2
            JOIN trips t2 ON tp2.trip_id = t2.trip_id
            WHERE tp2.client_id = tp.client_id
        )
    ORDER BY tp.client_id
    """

    df = pd.read_sql_query(text(query_last_trips), engine, params=param_dict)

# --- Krok 2: Zlicz podrÃ³Å¼e i sortuj ---
summary = df['trip_id'].value_counts().reset_index()
summary.columns = ['trip_id', 'num_clients']
summary = summary.sort_values(by='num_clients', ascending=False)
last_trips_ids = summary["trip_id"].tolist()

# --- Krok 3: SzczegÃ³Å‚y podrÃ³Å¼y ---
if not last_trips_ids:
    df_last_trips = pd.DataFrame(columns=["Planeta", "Typ wyprawy", "Pojazd", "Rakieta", "Id"])
else:
    placeholders = ','.join([f':id{i}' for i in range(len(last_trips_ids))])
    param_dict = {f'id{i}': tid for i, tid in enumerate(last_trips_ids)}

    query_trip_info = f"""
        SELECT 
            d.name AS destination,
            tt.name AS trip_type,
            s.name AS spacecraft_name,
            r.name AS rocket_name,
            t.trip_id
        FROM trip_participants tp
        JOIN trips t ON tp.trip_id = t.trip_id
        JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
        JOIN rockets r ON t.rocket_id = r.rocket_id
        JOIN destinations d ON t.destination_id = d.destination_id
        JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
        WHERE tp.trip_id IN ({placeholders})
        GROUP BY t.trip_id, d.name, tt.name
    """
    df_last_trips = pd.read_sql_query(text(query_trip_info), engine, params=param_dict)

# --- Formatowanie koÅ„cowe ---
df_last_trips.columns = ["Planeta", "Typ wyprawy", "Pojazd", "Rakieta", "Id"]
df_last_trips.index = pd.RangeIndex(start=1, stop=len(df_last_trips)+1)

# WyÅ›wietlenie wynikÃ³w
display(df_last_trips.head(10))
df_summary_markdown(df_last_trips.head(10))
```

Mamy juÅ¼ omÃ³wione te negatywne loty. Pora zatem sprawdziÄ‡, po ktÃ³rych wyprawach klienci wracajÄ… po wiÄ™cej. To nam pokaÅ¼e, ktÃ³re loty zostawiÄ‡ w ofercie. W poniÅ¼szym podsumowaniu bierzemy pod uwagÄ™ tylko te wyprawy, po ktÃ³rych klienci wrÃ³cili i odbyli kolejnÄ… wyprawÄ™. Od gÃ³ry bÄ™dziemy wypisywaÄ‡ te, ktÃ³re miaÅ‚y najwiÄ™cej powracajÄ…cych klientÃ³w.

```{python}
query = """
  SELECT tp.client_id, tp.trip_id, t.departure_datetime 
  FROM trip_participants tp
  JOIN trips t ON tp.trip_id = t.trip_id
  ORDER BY tp.client_id, t.departure_datetime
"""
df = pd.read_sql_query(text(query), engine)

# --- Krok 2: Analiza powrotÃ³w klientÃ³w ---
df['next_trip'] = df.groupby('client_id')['trip_id'].shift(-1)
df['returned_after'] = df['next_trip'].notna()

trip_retention = df[df['returned_after']].groupby('trip_id').size().reset_index(name='clients_returned')
trip_retention = trip_retention.sort_values(by='clients_returned', ascending=False)

top_5_ret_ids = trip_retention.head(10)["trip_id"].tolist()

# --- Krok 3: SzczegÃ³Å‚y dla najczÄ™Å›ciej powracanych podrÃ³Å¼y ---
if not top_5_ret_ids:
    df_liked_trips = pd.DataFrame(columns=["Planeta", "Typ wyprawy", "Pojazd", "Rakieta", "Id"])
else:
    placeholders = ','.join([f':id{i}' for i in range(len(top_5_ret_ids))])
    param_dict = {f'id{i}': tid for i, tid in enumerate(top_5_ret_ids)}

    query = f"""
        SELECT 
            d.name AS destination,
            tt.name AS trip_type,
            s.name AS spacecraft_name,
            r.name AS rocket_name,
            t.trip_id
        FROM trip_participants tp
        JOIN trips t ON tp.trip_id = t.trip_id
        JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
        JOIN rockets r ON t.rocket_id = r.rocket_id
        JOIN destinations d ON t.destination_id = d.destination_id
        JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
        WHERE tp.trip_id IN ({placeholders})
        GROUP BY t.trip_id, d.name, tt.name
    """
    df_liked_trips = pd.read_sql_query(text(query), engine, params=param_dict)

# --- Formatowanie i wyÅ›wietlenie ---
df_liked_trips.columns = ["Planeta", "Typ wyprawy", "Pojazd", "Rakieta", "Id"]
df_liked_trips.index = pd.RangeIndex(start=1, stop=len(df_liked_trips)+1)

display(df_liked_trips.head(10))
df_summary_markdown(df_liked_trips)
```

Mamy teraz przeglÄ…d najbardziej wpÅ‚ywowych lotÃ³w. Pytanie teraz brzmi, ktÃ³re zostawiamy, a ktÃ³rych naleÅ¼y siÄ™ pozbyÄ‡?

## Odnalezienie najlepiej ocenianego oraz najaktywniejszego pracownika

Interesuje nas wpÅ‚yw naszych pracownikÃ³w na wyprawy. Chcemy odnaleÅºÄ‡ pracownika, ktÃ³ry ma najlepszy wpÅ‚yw na ocenÄ™ lotÃ³w. BÄ™dziemy siÄ™ gÅ‚Ã³wnie skupiaÄ‡ na tych rolach, ktÃ³re majÄ…c bezpoÅ›redni kontakt z pasaÅ¼erami lub bezpoÅ›rednio wpÅ‚ywajÄ… na komfort podrÃ³Å¼y (np. Pilot, Kucharz). Dalej bÄ™dziemy chcieli odnaleÅºÄ‡ najaktywniejszego pracownika, czyli tego ktÃ³ry zostaÅ‚ przypisany do najwiÄ™kszej liczby wypraw. Chcemy tutaj znaleÅºÄ‡ tego, ktÃ³ry najwiÄ™cej wnosi do naszych lotÃ³w i bÄ™dziemy tu juÅ¼ badaÄ‡ wszystkie role.

#### Najlepiej oceniani pracownicy
```{python}
roles_of_interest = ["Pilot statku", "Specjalista ds. bezpieczeÅ„stwa","Lekarz pokÅ‚adowy", "Kucharz orbitalny"]
# --- Krok 1: Pobranie ocen przypisanych pracownikom ---
query = """
SELECT
    e.first_name AS ImiÄ™,
    e.last_name AS Nazwisko,
    e.position AS Pozycja,
    f.trip_id,
    ea.employee_id AS ID,
    f.rating AS Ocena
FROM employee_assignments ea
JOIN employees e ON ea.employee_id = e.employee_id
JOIN feedback f ON ea.trip_id = f.trip_id
"""
df_ratings_all = pd.read_sql_query(text(query), engine)

# --- Krok 2: Åšrednie oceny wszystkich pracownikÃ³w ---
avg_ratings_all = df_ratings_all.groupby(['ImiÄ™', 'Nazwisko', 'Pozycja','ID'])['Ocena'].mean().reset_index()
avg_ratings_all["Ocena"] = round(avg_ratings_all["Ocena"], 2)
avg_ratings_all = avg_ratings_all.sort_values(by="Ocena", ascending=False)

# --- Krok 3: Åšrednie oceny tylko dla interesujÄ…cych nas rÃ³l ---
roles_of_interest = ["Pilot statku", "Specjalista ds. bezpieczeÅ„stwa", "Lekarz pokÅ‚adowy", "Kucharz orbitalny"]
df_ratings_interest = df_ratings_all[df_ratings_all["Pozycja"].isin(roles_of_interest)]
avg_ratings_interest = df_ratings_interest.groupby(['ImiÄ™', 'Nazwisko', 'Pozycja','ID'])['Ocena'].mean().reset_index()
avg_ratings_interest["Ocena"] = round(avg_ratings_interest["Ocena"], 2)
avg_ratings_interest = avg_ratings_interest.sort_values(by="Ocena", ascending=False)

# --- WyÅ›wietlenie topowych ---
display(avg_ratings_interest.head(5).style.hide(axis="index"))

# --- Markdown z najlepszym pracownikiem ---
best_employee = avg_ratings_interest.iloc[0]
markmarkdown_text = f"""
ğŸ‘¨â€ğŸš€ Najlepszym pracownikiem okazaÅ‚ jest **{best_employee['ImiÄ™']} {best_employee['Nazwisko']}** o ID **{best_employee['ID']}** , ktÃ³ry przysÅ‚uÅ¼yÅ‚ nam siÄ™ pracujÄ…c jako **{best_employee['Pozycja']}**. Uzyskana ocena wynosi **{best_employee['Ocena']}**.
"""
display(Markdown(markmarkdown_text))
```

#### Najaktywniejsi pracownicy
```{python}
query = """
SELECT
    e.first_name AS ImiÄ™,
    e.last_name AS Nazwisko,
    e.position AS Pozycja,
    ea.employee_id AS ID,
    COUNT(ea.trip_id) AS Wyprawy
FROM employee_assignments ea
JOIN employees e ON ea.employee_id = e.employee_id
GROUP BY ea.employee_id, e.first_name, e.last_name, e.position
ORDER BY Wyprawy DESC
"""
df_acvitivy = pd.read_sql_query(text(query), engine)

# --- Krok 2: Filtrowanie po interesujÄ…cych rolach ---
df_acvitivy_interest = df_acvitivy[df_acvitivy["Pozycja"].isin(roles_of_interest)]

# --- Krok 3: Sortowanie i wyÅ›wietlanie ---
most_active = df_acvitivy.sort_values(by="Wyprawy", ascending=False)
most_active_of_interest = df_acvitivy_interest.sort_values(by="Wyprawy", ascending=False)

display(most_active.head(5).style.hide(axis="index"))

most_active_employee = most_active.iloc[0]

# --- Markdown z najlepszym pracownikiem pod wzglÄ™dem aktywnoÅ›ci ---
markmarkdown_text = f"""
ğŸ‘¨â€ğŸš€ Najbardziej aktywnym pracownikiem okazaÅ‚ jest **{most_active_employee['ImiÄ™']} {most_active_employee['Nazwisko']}** o ID {most_active_employee['ID']} , ktÃ³ry przysÅ‚uÅ¼yÅ‚ nam siÄ™ pracujÄ…c jako **{most_active_employee['Pozycja']}**. Liczba wycieczek, na ktÃ³re miaÅ‚ wpÅ‚yw ten niesamowity pracownik wynosi **{most_active_employee['Wyprawy']}**.
"""
display(Markdown(markmarkdown_text))
```

MajÄ…c informacje o tym kto w ktÃ³rej kategorii wypadÅ‚ najlepiej, chcemy zweryfikowaÄ‡ te wyniki w kategorii przeciwnej. To oznacza, Å¼e najlepiej ocenianego zbadamy pod kÄ…tem jego aktywnoÅ›ci, a najaktywniejszego pod kÄ…tem jego ocen.

```{python}

def ocena(percent):
    if percent > 90:
        return "wyÅ›mienity"
    elif percent > 75:
        return "bardzo dobry"
    elif percent > 50:
        return "dobry"
    elif percent > 25:
        return "umiarkowany"
    elif percent > 10:
        return "nie najlepszy"
    else:
        return "sÅ‚aby"                

best_employee_activity = df_acvitivy[df_acvitivy["ID"] == best_employee["ID"]]
most_active_employee_rating = avg_ratings_all[avg_ratings_all["ID"]== most_active_employee["ID"]]

df_acvitivy = df_acvitivy.reset_index(drop=True)
position = df_acvitivy.index[df_acvitivy["ID"] == best_employee["ID"]]


rank = position[0] + 1  # +1 bo indeksy zaczynajÄ… siÄ™ od 0
total = len(df_acvitivy)
percent_rank = 100 * (1 - (rank - 1) / (total - 1)) if total > 1 else   100
employee_rating = df_acvitivy.loc[position[0]]

markmarkdown_text = f"""
Najlepiej oceniany pracownik, **{best_employee['ImiÄ™']} {best_employee['Nazwisko']}**, wziÄ…Å‚ udziaÅ‚ w {employee_rating["Wyprawy"]} wyprawach, co jest wiÄ™cej niÅ¼ {percent_rank:.1f}% pracownikÃ³w. Jest to {ocena(percent_rank)} wynik.
"""

display(Markdown(markmarkdown_text))

avg_ratings_all = avg_ratings_all.reset_index(drop=True)
position = avg_ratings_all.index[avg_ratings_all["ID"] == most_active_employee["ID"]]


rank = position[0] + 1  # +1 bo indeksy zaczynajÄ… siÄ™ od 0
total = len(df_acvitivy)
percent_rank = 100 * (1 - (rank - 1) / (total - 1)) if total > 1 else   100
employee_rating = avg_ratings_all.loc[position[0]]

markmarkdown_text = f"""
Najaktywniejszy pracownik, **{most_active_employee['ImiÄ™']} {most_active_employee['Nazwisko']}**, uzyskaÅ‚ Ocena {employee_rating["Ocena"]}, co jest wynikiem lepszym od {percent_rank:.1f}% pracownikÃ³w. Jest to {ocena(percent_rank)} wynik.
"""
display(Markdown(markmarkdown_text))
```

## Roczna sezonowoÅ›Ä‡ wypraw i incydentÃ³w.
W tym podpunkcie bÄ™dziemy chcieli zbadaÄ‡ dwie rzeczy, ktÃ³re mogÄ… byÄ‡ ze sobÄ… powiÄ…zane. Chcemy kiedy w trakcie roku wystÄ™puje najwiÄ™cej lotÃ³w, czy sÄ… jakieÅ› trendy lub sezonowoÅ›Ä‡. DokÅ‚adnie to samo bÄ™dziemy chcieli sprawdziÄ‡ w kwestii incydentÃ³w, czy sÄ… okresy kiedy zdarzajÄ… siÄ™ czÄ™Å›ciej?

```{python}
# --- Krok 1: Daty podrÃ³Å¼y ---
query = "SELECT trip_id, departure_datetime FROM trips"
df_trips = pd.read_sql_query(text(query), engine)

df_trips['departure_datetime'] = pd.to_datetime(df_trips['departure_datetime'], format='%Y-%m-%d %H:%M:%S')
df_trips['year_month'] = df_trips['departure_datetime'].apply(lambda x: f"{x.year}-{x.month:02d}")
df_trips['year'] = df_trips['departure_datetime'].dt.year
df_trips['month'] = df_trips['departure_datetime'].dt.month

trip_counts = df_trips['month'].value_counts().sort_index()

# --- Krok 2: Daty incydentÃ³w ---
query = "SELECT incident_id, datetime_occurred FROM incidents"
df_incidents = pd.read_sql_query(text(query), engine)

df_incidents['datetime'] = pd.to_datetime(df_incidents['datetime_occurred'], format='%Y-%m-%d %H:%M:%S')
df_incidents['year_month'] = df_incidents['datetime'].apply(lambda x: f"{x.year}-{x.month:02d}")
df_incidents['year'] = df_incidents['datetime'].dt.year
df_incidents['month'] = df_incidents['datetime'].dt.month

incidents_counts = df_incidents['month'].value_counts().sort_index()

all_months = list(range(1, 13))
trip_counts = trip_counts.reindex(all_months, fill_value=0)
incidents_counts = incidents_counts.reindex(all_months, fill_value=0)

x = np.arange(len(all_months))
width = 0.35


df_plot = pd.DataFrame({
    "MiesiÄ…c": [f"{m:02d}" for m in all_months],
    "Liczba wycieczek": trip_counts.values,
    "Liczba incydentÃ³w": incidents_counts.values
})

# Zmiana na long format (wymagane przez plotly.express do grouped bar chart)
df_melted = df_plot.melt(id_vars="MiesiÄ…c", var_name="Typ", value_name="Liczba")

# Rysowanie wykresu
fig = px.bar(
    df_melted,
    x="MiesiÄ…c",
    y="Liczba",
    color="Typ",
    barmode="group",
    title="PorÃ³wnanie liczby wycieczek i incydentÃ³w wg miesiÄ…ca"
)

fig.update_layout(xaxis_title="MiesiÄ…c", yaxis_title="Liczba")
fig.show()
```

Na powyÅ¼szym wykresie moÅ¼emy zobaczyÄ‡ obok siebie, jak czÄ™sto wystÄ™powaÅ‚y loty i incydenty.

## Czy klienci dokonujÄ… pÅ‚atnoÅ›ci za przejazdy z wyprzedzeniem, czy czekajÄ… do ostatniej chwili?

Interesuje nas prosta, lecz waÅ¼na kwestia. Kiedy wpÅ‚ywajÄ… zapÅ‚aty za wyprawÄ™. OczywiÅ›cie dla nas najlepiej byÅ‚oby, gdyby klient wypÅ‚acaÅ‚ pieniÄ…dze jak najwczeÅ›niej. Chcemy zbadaÄ‡, czy duÅ¼o klientÃ³w ociÄ…ga siÄ™ z pÅ‚atnoÅ›ciÄ…. MoÅ¼e potrzebne bÄ™dzie pogonienie ich lub naÅ‚oÅ¼enie kar?

```{python}
query = """
SELECT
    ts.client_id,
    ts.trip_id,
    ts.transaction_date,
    t.departure_datetime,
    DATEDIFF(t.departure_datetime, ts.transaction_date) AS days_before_trip
FROM transactions ts
JOIN trips t ON ts.trip_id = t.trip_id
"""
df = pd.read_sql_query(text(query), engine)

bins = [-100, 0, 3, 7, 14, 30, 90, 365]
labels = ['Po czasie', '0-3 dni', '4-7 dni', '8-14 dni', '15-30 dni', '31-90 dni', '91+ dni']
df['payment_window'] = pd.cut(df['days_before_trip'], bins=bins, labels=labels)

summary = df['payment_window'].value_counts().sort_index()
df_summary = summary.reset_index()
df_summary.columns = ['Okno czasowe', 'Liczba pÅ‚atnoÅ›ci']

fig = px.bar(
    df_summary,
    x='Okno czasowe',
    y='Liczba pÅ‚atnoÅ›ci',
    title='Kiedy klienci pÅ‚acÄ… za wycieczki?',
    labels={'Okno czasowe': 'Ile dni przed wyjazdem dokonano pÅ‚atnoÅ›ci'}
)

fig.update_layout(xaxis_title='Okno czasowe', yaxis_title='Liczba pÅ‚atnoÅ›ci')
fig.show()
```

## Ulubione metody pÅ‚atnoÅ›ci naszych klientÃ³w. Z jakiego ÅºrÃ³dÅ‚a wpÅ‚ywa najwiÄ™cej pieniÄ™dzy.

W tym podpunckcie zbadamy waÅ¼nÄ… kwestiÄ™ finansowÄ…. Chcemy poznaÄ‡ preferencje pÅ‚atnicze naszych klientÃ³w. To da nam informacje o tym, ile pieniÄ™dzy jest przesyÅ‚anych danym sposobem pÅ‚atnoÅ›ci. BÄ™dziemy wtedy wiedzieÄ‡, czy moÅ¼e warto bÄ™dzie zainwestowaÄ‡ w to, aby korzystanie z niego byÅ‚o prostsze i bardziej opÅ‚acalne.

```{python}
query = """
SELECT
    payment_method,
    COUNT(*) AS total_transactions,
    SUM(amount) AS total_amount
FROM transactions
WHERE status = 'completed'
GROUP BY payment_method
ORDER BY total_amount DESC
"""
df_methods = pd.read_sql_query(text(query), engine)

# --- Krok 2: (opcjonalne) dodanie okna pÅ‚atnoÅ›ci, jeÅ›li df i diff sÄ… zdefiniowane ---
# ZakÅ‚adam, Å¼e zmienna `df` i kolumna `diff` (days_before_trip) sÄ… juÅ¼ wczeÅ›niej utworzone.

bins = [-100, 0, 3, 7, 14, 30, 90, 365]
labels = ['Po czasie', '0-3 dni', '4-7 dni', '8-14 dni', '15-30 dni', '31-90 dni', '91+ dni']
df['payment_window'] = pd.cut(df['days_before_trip'], bins=bins, labels=labels)

from plotly.subplots import make_subplots
import plotly.graph_objects as go

fig = make_subplots(
    rows=2, cols=1,
    shared_xaxes=True,
    vertical_spacing=0.15,
    subplot_titles=(
        "ğŸ’° Å¹rÃ³dÅ‚a najwiÄ™kszego przychodu wg metody pÅ‚atnoÅ›ci",
        "ğŸ“Š PopularnoÅ›Ä‡ metod pÅ‚atnoÅ›ci wg liczby uÅ¼yÄ‡"
    )
)

# Wiersz 1: ÅÄ…czna kwota
fig.add_trace(
    go.Bar(
        x=df_methods["payment_method"],
        y=df_methods["total_amount"],
        name="ÅÄ…czna kwota",
        marker_color="skyblue"
    ),
    row=1, col=1
)

# Wiersz 2: Liczba transakcji
fig.add_trace(
    go.Bar(
        x=df_methods["payment_method"],
        y=df_methods["total_transactions"],
        name="Liczba transakcji",
        marker_color="lightgreen"
    ),
    row=2, col=1
)

# Ustawienia osi, tytuÅ‚u itd.
fig.update_layout(
    height=700,
    showlegend=False,
    xaxis_tickangle=45
)

fig.update_xaxes(title_text="Metoda pÅ‚atnoÅ›ci", row=2, col=1)
fig.update_yaxes(title_text="Kwota", row=1, col=1)
fig.update_yaxes(title_text="Liczba transakcji", row=2, col=1)

fig.show()
```
